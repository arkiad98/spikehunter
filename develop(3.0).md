SpikeHunter v3.0 개발 로그
이 문서는 v2.9 이후 AI 어시스턴트(Gemini)와 협업하여 모델의 예측력을 강화하고, 시스템의 안정성을 확보하며, 최종 강건성을 검증하는 과정을 기록합니다.


## v3.0.1: 피처 엔지니어링 시스템 설계

### v3.0.1.1: '범용 피처 유의성 분석기' 애드온 설계
- **문제 인식**: 새로운 피처 아이디어를 검증하고, 기존 피처의 유효성을 평가하기 위한 체계적인 시스템의 부재.
- **해결**: 개별 피처의 성능 기여도(Lift)를 자동으로 측정하고, 최적의 조합을 탐색하는 '피처 엔지니어링 스위트' 애드온(`addon_feature_engineering_suite.py`)을 설계함.

### v3.0.1.2: '피처 레지스트리' 도입 (`feature_registry.yaml`)
- **문제 인식**: 피처 목록이 코드 내에 하드코딩되어 있어 관리 및 확장이 어려움.
- **해결**: 모든 피처의 메타데이터(상태, 카테고리, 설명 등)를 관리하는 중앙 레지스트리 `config/feature_registry.yaml`을 도입함. 이를 통해 피처의 상태(`core`, `candidate`, `deprecated`)를 동적으로 변경하여 분석 파이프라인을 제어할 수 있는 기반을 마련함.

## v3.0.2: 코드 리팩토링 및 안정화

### v3.0.2.1: 피처 로직 모듈 분리 (`features.py`)
- **문제 인식**: `derive.py` 모듈에 피처 계산 로직과 데이터 파이프라인 운영 로직이 혼재되어 유지보수가 어려움.
- **해결**: 모든 피처 계산 로직을 `modules/features.py`라는 별도의 모듈로 분리함. `derive.py`는 이 모듈을 호출하는 역할만 담당하도록 구조를 리팩토링하여 코드의 모듈성, 가독성, 확장성을 크게 향상시킴.

### v3.0.2.2: `derive.py` 병렬 처리 로깅 문제 해결
- **문제 인식**: `derive.py`의 월별 병렬 처리 과정에서 여러 프로세스의 로그가 뒤섞여 출력되는 심각한 가독성 문제 발생.
- **해결 과정**:
    1. **시도 1 (`QueueHandler`)**: 표준 해결책인 `multiprocessing.Queue`와 `QueueHandler`를 도입했으나, `partial`, `starmap`, `imap` 등 다양한 방식에서 `RuntimeError: Queue objects should only be shared through inheritance` 및 `PicklingError`가 반복적으로 발생하며 환경 호환성 문제에 직면함.
    2. **시도 2 ('개별 파일 로깅')**: 각 작업자가 독립된 로그 파일에 기록하고 나중에 취합하는 방식을 논의함.
    3. **최종 결정 ('순차 처리')**: 여러 차례의 디버깅 실패 후, 가장 중요한 것은 안정성과 로그 가독성이라는 결론에 도달함. **`multiprocessing.Pool`을 제거하고, 월별 순차 `for` 루프 방식으로 코드를 최종 확정**하여 문제를 근본적으로 해결함.

## v3.0.3: 고급 피처 엔지니어링 및 검증

### v3.0.3.1: 신규 고급 피처 3종 설계 및 추가
- **목표**: 단일 지표를 넘어, 피처 간의 관계 및 시장 상황을 모델에 학습시키기 위해 3종의 고급 피처를 설계하고 `features.py`에 추가함.
    1. **상호작용 피처**: `momentum_x_flow` (주가 모멘텀 × 외국인 수급)
    2. **시계열 델타 피처**: `rsi_roc_3d` (RSI의 3일간 변화율)
    3. **시장 국면 피처**: `regime_R1` ~ `R4` (KOSPI 기준 시장 상황)

### v3.0.3.2: '개별 피처 유의성 분석' 실행 및 결과 분석
- **실행**: 새로 구축한 '피처 엔지니어링 스위트'를 통해, 기존 `core` 피처 10개 대비 신규 피처 및 기타 `candidate` 피처들의 성능 기여도(Lift)를 'Average Precision' 기준으로 측정함.
- **핵심 발견**:
    - **유망 피처**: `regime_R1`(+0.0144), `regime_R3`(+0.0053), `momentum_x_flow`(+0.0023)가 뚜렷한 성능 향상을 보임.
    - **부진 피처**: `regime_R2`, `regime_R4`, `rsi_roc_3d` 등은 오히려 성능을 저하시키는 노이즈로 작용함을 확인함.

## v3.0.4: 최종 모델 확정

### v3.0.4.1: 최종 `Core` 피처 그룹 확정
- **결정**: '개별 피처 유의성 분석' 결과를 바탕으로, 성능 향상이 검증된 **`regime_R1`, `regime_R3`, `momentum_x_flow`** 3개 피처를 `core` 그룹으로 승격함.
- **최종 구성**: 기존 10개 피처에 3개를 더한 **총 13개의 피처**를 최종 `core` 피처 그룹으로 확정함.

### v3.0.4.2: 시스템 전반의 일관성 확보
- **문제 인식**: Optuna 최적화(`addon_feature_optimizer.py`)와 모델 학습(`train.py`) 등 여러 모듈에서 각기 다른 평가 지표(AUC)나 피처 목록을 하드코딩하여 사용하는 불일치 문제 발견.
- **해결**:
    - 모든 모듈이 `feature_registry.yaml`을 '단일 진실 공급원(Single Source of Truth)'으로 삼아 `core` 피처 목록을 동적으로 읽어오도록 수정함.
    - LightGBM의 `metric` 설정과 Optuna의 평가 기준을 모두 **'Average Precision'**으로 통일하여 학습과 평가의 목표를 일치시킴.


============================================================
Version 3.0: 최종 모델 강건성 검증 및 성과 분석 (2025-10-10)
============================================================
✨ 핵심 목표 달성: 피처 선택 및 하이퍼파라미터 최적화가 완료된 최종 모델의 실전 강건성(Robustness)을 Walk-Forward 테스트를 통해 최종 검증했습니다.

1. Walk-Forward 테스트 실행 및 결과 분석
    - 실행: 약 5.5년의 전체 기간에 대해 7개의 기간(Period)으로 나누어 Walk-Forward 테스트를 성공적으로 완료했습니다.
    - 핵심 성과: 초기 자본 1,000만원이 최종 자산 **29.2억원**으로 증가했으며, **연복리수익률(CAGR) 143.4%**, **샤프 지수 2.16**, 최대 낙폭(MDD) -22.75%라는 경이로운 성과를 기록했습니다.
    - 분석: 특히 마지막 1년(Period 6, 7) 동안의 폭발적인 성장이 전체 수익률을 견인했음을 확인했습니다. 이는 특정 시장 상황에서 모델과 전략이 매우 효과적으로 작동했음을 증명합니다.
    - 결론: 현재 모델 및 전략 파라미터가 매우 높은 수준의 최적점에 도달했음을 확인했으며, 추가적인 파라미터 튜닝보다는 현재 성과의 원인을 분석하여 재현 가능성을 검증하는 것이 더 중요하다고 판단했습니다.

2. 목표가 추정 애드온 통합
    - 문제: `addon_predict_target.py`가 `run_pipeline.py`의 메인 메뉴에 통합되어 있지 않은 문제를 확인했습니다.
    - 해결: `run_pipeline.py`의 메인 메뉴를 수정하여, '데일리 추천 종목 생성' 이후에 바로 목표가를 분석할 수 있도록 '[부가 분석]' 메뉴를 추가하고 해당 기능을 통합했습니다.
    - 안정성 확보: 통합 과정에서 오래된 코드로 인해 발생한 `KeyError: 'close'` 오류를, 데이터프레임 병합 시 컬럼명 충돌(`close_x`, `close_y`)이 원인임을 밝혀내고, 데이터 소스를 일원화하는 방식으로 코드를 수정하여 해결했습니다.

============================================================
Version 3.0: 피처 엔지니어링 및 ML 파이프라인 고도화 (2025-10-09)
============================================================
✨ 핵심 목표: 모델의 정밀도(Precision) 향상을 위해, 피처의 유효성을 검증하고 최적의 피처 조합을 탐색하는 체계적인 연구개발 워크플로우를 구축하고 실행했습니다.

1. '핵심 피처 안정성 분석' 기능 개발
    - 목표: 경험적으로 인지하고 있던 "상위 핵심 피처는 변동성이 적다"는 가설을 데이터로 증명하기 위한 진단 도구를 개발했습니다.
    - 구현: `addon_feature_stability_analyzer.py`를 신규 개발. 롤링 윈도우(Rolling Window) 방식으로 기간별 피처 중요도 순위를 반복 측정하고, 피처별 '평균 순위'와 '순위 표준편차'를 계산하여 안정성을 정량화했습니다.
    - 결과: 분석을 통해 `atr_norm_14d` 등 상위 7개 피처가 실제로 시간이 지나도 꾸준히 높은 중요도를 유지하는 '핵심 피처'임을 통계적으로 증명했습니다.

2. '지능형 피처 조합 최적화' 기능 개발 및 실행
    - 목표: 안정성이 증명된 '핵심 피처'를 기반으로, 어떤 '추가 피처'를 조합할 때 모델 성능이 가장 향상되는지를 효율적으로 탐색하는 기능을 개발했습니다.
    - 구현: `addon_feature_optimizer.py`를 신규 개발. '핵심 피처'는 항상 포함시키고, 나머지 '후보 피처'들 중에서 몇 개를 추가할지를 Optuna가 탐색하도록 '지능형 탐색' 로직을 구현했습니다.
    - 디버깅:
        - 초기 실행 시 발생한 저수준 메모리 충돌(`double free or corruption`) 문제를, Dask 병렬 처리 환경과 하위 라이브러리(NumPy/OpenBLAS)의 스레드 충돌이 원인임을 규명하고, 스크립트 실행 전 `os.environ`을 통해 스레드 수를 '1'로 강제하는 방식으로 해결했습니다.
        - 이후 발생한 '좀비 프로세스' 문제(프로세스 멈춤)를, Dask Worker의 메모리 한도를 명시적으로 설정하고 코드 내 가비지 컬렉션을 추가하여 해결했습니다.
    - 결과: 최적화 결과, '핵심 피처 7개 + `atr14` 1개' 조합이 가장 좋은 성능(AUC 0.6645)을 보였으나, 피처를 추가하지 않은 '핵심 피처 7개' 조합과의 성능 차이가 미미함을 확인했습니다. 이를 통해 "더 적은 것이 더 낫다"는 결론을 도출하고, **최종 피처셋을 '핵심 피처 7개'로 확정**하는 중요한 의사결정을 내렸습니다.

3. ML 파이프라인 개선 및 버그 수정
    - 문제 1: 확정된 7개 피처셋을 분류 모델에만 적용해야 하는데, `_get_feature_cols` 함수를 수정할 경우 회귀 모델까지 영향을 받는 문제.
    - 해결 1: `train.py`의 `_run_classification_training` 함수 내부에서만 7개 피처를 사용하도록 명시적으로 코드를 수정하여, 회귀 모델에 영향을 주지 않고 분류 모델의 피처셋만 변경했습니다.
    - 문제 2: 하이퍼파라미터 최적화 시에는 위 수정사항이 적용되지 않아 여전히 31개 피처를 사용하는 문제.
    - 해결 2: `train.py`의 `Objective` 클래스 내부 데이터 준비 로직에도 동일하게 7개 피처셋을 사용하도록 코드를 추가하여, 일반 학습과 최적화 시의 피처 일관성을 확보했습니다.
    - 문제 3: 최적화 목표를 `AUC`에서 `Average Precision`으로 변경했으나, Optuna가 여전히 최소화(minimize)를 시도하는 문제.
    - 해결 3: `train.py`의 최적화 방향 결정 로직에 `Average Precision`을 `maximize` 대상으로 명시적으로 추가하여 문제를 해결했습니다.
    - 문제 4: Walk-Forward 테스트 중 `_train_and_evaluate_classification_model` 함수 호출 시 `threshold` 인자가 누락되어 `TypeError` 발생.
    - 해결 4: `run_pipeline.py`의 `run_walk_forward_pipeline` 함수에서 `settings.yaml`의 임계값을 읽어와 해당 인자를 전달하도록 수정했습니다.