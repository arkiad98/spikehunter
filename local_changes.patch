diff --git a/addons/addon_threshold_optimizer.py b/addons/addon_threshold_optimizer.py
index 5d955a6..f25d061 100644
--- a/addons/addon_threshold_optimizer.py
+++ b/addons/addon_threshold_optimizer.py
@@ -130,11 +130,36 @@ def run_threshold_optimization(settings_path: str):
     
     print("="*80)
     
-    # 설정 파일 업데이트
-    apply_val = float(best_balanced['Threshold'])
-    choice = get_user_input(f"\n'실전 권장값 ({apply_val:.2f})'을 설정 파일에 적용하시겠습니까? (y/n): ")
+    # 설정 파일 업데이트 메뉴
+    print("\n" + "="*80)
+    print(" [설정 적용 메뉴]")
+    print(f" 1. 이론적 최적값 적용 (Threshold {best_f1['Threshold']:.2f})")
+    print(f" 2. 실전 권장값 적용 (Threshold {best_balanced['Threshold']:.2f})")
+    print(f" 3. 수동 값 입력")
+    print("="*80)
     
-    if choice.lower() == 'y':
+    choice = get_user_input("\n원하는 옵션 번호를 입력하세요 (1/2/3): ")
+    
+    apply_val = None
+    
+    if choice == '1':
+        apply_val = float(best_f1['Threshold'])
+    elif choice == '2':
+        apply_val = float(best_balanced['Threshold'])
+    elif choice == '3':
+        while True:
+            try:
+                val_str = get_user_input("적용할 Threshold 값을 입력하세요 (예: 0.55): ")
+                val = float(val_str)
+                if 0.0 < val < 1.0:
+                    apply_val = val
+                    break
+                else:
+                    print("값은 0과 1 사이여야 합니다.")
+            except ValueError:
+                print("유효한 숫자를 입력해주세요.")
+    
+    if apply_val is not None:
         # [수정] update_yaml 대신 직접 ruamel.yaml을 사용하여 단일 값 업데이트
         from ruamel.yaml import YAML
         
diff --git a/config/settings.yaml b/config/settings.yaml
index c69ba35..558767e 100644
--- a/config/settings.yaml
+++ b/config/settings.yaml
@@ -37,7 +37,7 @@ ml_params:
   target_hold_period: 5
   regression_sampling_quantile: 0.9
   classification_train_months: 36
-  classification_threshold: 0.21000000000000005
+  classification_threshold: 0.5000000000000003
 
   # [복구] 사용자 요청: LightGBM 단일 모델 원복
   active_model: "lgbm"
@@ -47,13 +47,13 @@ ml_params:
   lgbm_params_classification:
     objective: binary
     metric: average_precision
-    scale_pos_weight: 8.304453082647894 # [Restored] Exact Value
-    n_estimators: 540     # [Restored] High estimators for low LR
-    learning_rate: 0.012763748069217377 # [Restored] Low LR
-    num_leaves: 94        # [Restored] Simple Model
-    max_depth: 17         # [Restored] Shallow Depth
-    colsample_bytree: 0.9125967578720843
-    subsample: 0.8480084483844194
+    scale_pos_weight: 9.198968157107776 # [Restored] Exact Value
+    n_estimators: 331     # [Restored] High estimators for low LR
+    learning_rate: 0.005054016831797518 # [Restored] Low LR
+    num_leaves: 130       # [Restored] Simple Model
+    max_depth: 4          # [Restored] Shallow Depth
+    colsample_bytree: 0.5866907599874457
+    subsample: 0.9918244986081486
     n_jobs: 4
     verbose: -1
 
@@ -67,7 +67,7 @@ ml_params:
       colsample_bytree: {type: float, low: 0.5, high: 1.0}
       subsample: {type: float, low: 0.5, high: 1.0}
       min_child_samples: {type: int, low: 10, high: 100}
-    min_child_samples: 99
+    min_child_samples: 100
 
   # [NEW] XGBoost 파라미터
   xgb_params_classification:
@@ -140,7 +140,7 @@ strategies:
     target_r: 0.09990738335325917 # [수정] 예측력 우선 초기값
     stop_r: -0.027337402392375594 # [수정] 하한 -5%
     max_hold: 5
-    min_ml_score: 0.21000000000000005 # [수정] 무난한 시작값
+    min_ml_score: 0.5000000000000003  # [수정] 무난한 시작값
     vbo_k: 0.5417664494167612
     max_market_vol: 0.03024315171837781
     min_mfi: 46.79727604441189
diff --git a/modules/collect.py b/modules/collect.py
index 0e19d18..e986949 100644
--- a/modules/collect.py
+++ b/modules/collect.py
@@ -37,6 +37,32 @@ from modules.utils_io import (
 )
 from modules.utils_logger import logger
 
+# [Fix] 2026년 Year Transition Issue 대응을 위한 Monkeypatch
+# 1. '지수명' KeyError 방지 (pykrx 내부 get_index_ticker_name 함수 패치)
+try:
+    from pykrx.stock import stock_api
+    from unittest.mock import patch
+    
+    # 원본 함수 저장 (혹시 필요할 경우를 대비)
+    _original_get_index_ticker_name = stock_api.get_index_ticker_name
+    
+    def _patched_get_index_ticker_name(ticker):
+        if str(ticker) == "1001":
+            return "KOSPI"
+        if str(ticker) == "2001":
+             return "KOSDAQ"
+        try:
+            return _original_get_index_ticker_name(ticker)
+        except KeyError:
+            return str(ticker) # Fallback to ticker ID if name lookup fails
+            
+    # 패치 적용 (함수 바꿔치기)
+    stock_api.get_index_ticker_name = _patched_get_index_ticker_name
+    logger.info("Applied 'get_index_ticker_name' monkeypatch for 2026 compatibility.")
+    
+except Exception as e:
+    logger.warning(f"Failed to apply pykrx monkeypatch: {e}")
+
 REQUIRED_RAW_COLS = [
     "date", "code", "open", "high", "low", "close", "volume", "value",
     "inst_net_val", "foreign_net_val"
@@ -247,7 +273,8 @@ def run_collect(settings_path: str, start: str = None, end: str = None, use_meta
     
     try:
         logger.info("전체 수집 기간의 실제 영업일 목록을 조회합니다...")
-        all_trading_days_full_period = stock.get_index_ohlcv('20200101', end_d.strftime('%Y%m%d'), "1001").index
+        # KOSPI 지수(1001) 대신 삼성전자(005930)를 사용하여 영업일 확인 (2026년 버그 우회)
+        all_trading_days_full_period = stock.get_market_ohlcv('20200101', end_d.strftime('%Y%m%d'), "005930").index
     except Exception as e:
         logger.error(f"영업일 목록 조회 중 오류 발생: {e}. 데이터 수집을 중단합니다.")
         return False
diff --git a/modules/predict.py b/modules/predict.py
index f0d9444..590f5c4 100644
--- a/modules/predict.py
+++ b/modules/predict.py
@@ -223,8 +223,9 @@ def get_target_business_day() -> Optional[pd.Timestamp]:
     start_str = (now - timedelta(days=14)).strftime("%Y%m%d")
     
     try:
-        # KOSPI 지수 데이터를 이용해 영업일 리스트 확인 (티커 '1001'은 코스피)
-        df_index = stock.get_index_ohlcv(start_str, end_str, "1001")
+        # KOSPI 지수 데이터 대신 삼성전자(005930) 데이터를 이용해 영업일 리스트 확인
+        # (pykrx 2026년 지수 데이터 조회 시 KeyError 발생 우회)
+        df_index = stock.get_market_ohlcv(start_str, end_str, "005930")
         if df_index.empty:
             logger.error("영업일 목록을 가져올 수 없습니다.")
             return None
