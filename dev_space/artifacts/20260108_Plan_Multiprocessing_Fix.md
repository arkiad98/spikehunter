# 구현 계획 - [수정안] 인메모리 기반 멀티프로세싱 (SQL 제거)

사용자 피드백을 반영하여, SQL DB를 사용하지 않고 **순수 인메모리 방식**으로 멀티프로세싱을 구현합니다.
`Optuna`의 **Ask-and-Tell 패턴**을 활용하여 메인 프로세스가 파라미터를 관리하고, 작업 프로세스(Worker)는 계산만 전담하는 구조입니다.

## 핵심 변경 사항
- **SQL DB 제거**: 복잡한 DB 파일 생성이나 연결 없이, 기존처럼 메모리 상에서 최적화 상태(`study`)를 관리합니다.
- **Ask-and-Tell 패턴 도입**:
  1. **Ask**: 메인 프로세스에서 `n_jobs`(코어 수)만큼의 파라미터 조합을 한 번에 생성합니다.
  2. **Parallel Run**: `joblib`을 사용해 여러 프로세스에서 동시에 백테스트를 수행합니다.
  3. **Tell**: 계산된 결과(점수)를 메인 프로세스로 수집하여 최적화 모델을 갱신합니다.
  4. 이를 목표 횟수만큼 반복합니다.

## [안전장치 추가] 메모리 초과 방지 (Memory Safety)
현재 데이터셋 크기는 약 **460MB**입니다. 20개 코어에서 단순 복사(Copy) 방식으로 실행 시 약 **9GB** 이상의 메모리가 추가 소모되어 16GB 램 환경에서는 위험할 수 있습니다.
이를 방지하기 위해 **메모리 매핑(Memory Mapping)** 기술을 적용합니다.

### 데이터 공유 전략
1. **메인 프로세스**: 전처리된 대형 데이터프레임을 임시 파일(Memory Map File)로 덤프합니다. (`joblib.dump`)
2. **워커 프로세스**: 데이터를 복사하는 대신, 디스크에 있는 파일을 **읽기 전용(`mmap_mode='r'`)**으로 매핑하여 참조합니다.
3. **효과**: 모든 프로세스가 **하나의 메모리 공간**을 공유하므로, 프로세스가 100개가 되어도 메모리 사용량은 늘어나지 않습니다.

## 변경 제안 (Proposed Changes)

### `modules/optimization.py`

#### `run_batch_optimization`
- 데이터프레임을 `tempdata.joblib` 등의 임시 파일로 저장.
- `joblib.Parallel` 호출 시 데이터를 직접 넘기지 않고 **파일 경로**만 전달하거나, `joblib`의 자동 멤맵 기능을 활성화.
- 실행 후 임시 파일 삭제.

#### `_worker_backtest`
- 인자로 받은 (또는 로드한) 데이터프레임을 사용하여 백테스트 수행.
- 데이터 수정이 필요할 경우 `.copy()`를 수행해야 하나, 백테스트 로직은 주로 읽기 작업이므로 메모리 효율 유지 가능.

## 검증 계획
1. **변수 전달 테스트**: 파라미터 딕셔너리가 워커 프로세스로 잘 전달되고, 결과가 메인으로 잘 돌아오는지 확인.
2. **CPU 로드 확인**: '전략 최적화' 실행 시 작업 관리자의 CPU 그래프가 치솟는지 확인.
3. **메모리 안정성**: 최적화 도중 메모리 점유율 폭등 없이 안정적인지 확인.
